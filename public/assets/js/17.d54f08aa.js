(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{568:function(a,t,v){"use strict";v.r(t);var s=v(13),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202204130016018.png",alt:"jvm基本架构"}})]),a._v(" "),v("p",[a._v("jvm（java virtual machine）是java运行不可或缺的一部分，由类加载器、运行时数据区（Runtime Data Areas）、字节码执行引擎组成")]),a._v(" "),v("h3",{attrs:{id:"双亲委派模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型"}},[a._v("#")]),a._v(" 双亲委派模型")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202404151428069.png",alt:""}})]),a._v(" "),v("p",[a._v("除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器")]),a._v(" "),v("p",[a._v("父类加载失败，由子类加载器自己处理")]),a._v(" "),v("h4",{attrs:{id:"工作过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工作过程"}},[a._v("#")]),a._v(" 工作过程")]),a._v(" "),v("p",[a._v("1.一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此")]),a._v(" "),v("p",[a._v("2.所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时")]),a._v(" "),v("p",[a._v("3.子加载器才会尝试自己去加载")]),a._v(" "),v("h4",{attrs:{id:"好处"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#好处"}},[a._v("#")]),a._v(" 好处")]),a._v(" "),v("p",[a._v("1.使得Java类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一，避免了多份同样字节码的加载(类的重复加载)")]),a._v(" "),v("p",[a._v("2.java核心api中定义类型不会被随意替换，可以防止核心API库被随意篡改。例如：通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类")]),a._v(" "),v("p",[a._v("加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的")]),a._v(" "),v("p",[a._v("Integer.class。")]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"基本组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本组件"}},[a._v("#")]),a._v(" 基本组件")]),a._v(" "),v("h3",{attrs:{id:"堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202204182117083.png",alt:"堆"}})]),a._v(" "),v("h4",{attrs:{id:"堆跟栈的联系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆跟栈的联系"}},[a._v("#")]),a._v(" 堆跟栈的联系")]),a._v(" "),v("p",[a._v("栈的局部变量空间，放的是堆中对象的地址。")]),a._v(" "),v("h4",{attrs:{id:"gc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc"}},[a._v("#")]),a._v(" GC")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202204191947882.png",alt:""}})]),a._v(" "),v("p",[a._v("可达性分析算法可以解决gc root的循环引用问题")]),a._v(" "),v("p",[a._v("当eden区存放满了之后，字节码执行引擎就会开启一个线程，执行minor gc。")]),a._v(" "),v("p",[a._v("在方法区里面找能作为gc root的局部变量，根据这个局部变量找到引用的堆中的实际变量，直至这个变量不再引用任何对象（不是从gc root出发的对象都是垃圾对象），并把非垃圾对象复制一份放到survivor区，并清空eden区")]),a._v(" "),v("p",[a._v("（对象一旦被挪到survivor区，他们的分代年龄就会+1）")]),a._v(" "),v("p",[a._v("当程序继续运行，如果eden区对象又满了，算法就会把非空的survivor区也一并回收。最后把存活的对象复制到另一份survivor区中")]),a._v(" "),v("p",[a._v("当对象的分代年龄到达15，则会在最后一次minor gc后把此对象放到老年代中。老年代一般是连接池、spring的bean、缓存对象、静态对象...")]),a._v(" "),v("p",[a._v("当老年代放满了之后，jvm会做一个full gc，直接把整个堆中的对象回收")]),a._v(" "),v("p",[a._v("jvm调优，就是为了减少gc的次数以及时间（包括full gc的执行次数以及执行时间）")]),a._v(" "),v("p",[a._v("==所以full gc是什么时候触发的？跟oom有啥关系？==")]),a._v(" "),v("p",[a._v("老年代放满了，产生full gc；如果老年代放满了，程序还一直在不停地放对象，就会产生oom。")]),a._v(" "),v("p",[a._v("==为什么jvm的设计人员要设计STW（stop the world）机制？==")]),a._v(" "),v("p",[a._v("先单线程把gc做了，把整个容器的性能提高。如果不这样做，jvm堆里面的对象很难判断哪些是垃圾哪些是非垃圾")]),a._v(" "),v("p",[a._v("==大对象、长期存活的对象会直接进入老年代==")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202211142116507.png",alt:""}})]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202211142118274.png",alt:"image-20221114211828242"}})]),a._v(" "),v("h5",{attrs:{id:"对象头"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象头"}},[a._v("#")]),a._v(" 对象头")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202211012238878.png",alt:""}})]),a._v(" "),v("h3",{attrs:{id:"栈-filo-first-in-last-of-先进后出"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈-filo-first-in-last-of-先进后出"}},[a._v("#")]),a._v(" 栈（FILO First In Last Of 先进后出）")]),a._v(" "),v("p",[a._v("每一个线程开始执行，java虚拟机就会分配一个内存空间（栈），用来存放局部变量。")]),a._v(" "),v("p",[a._v("==栈帧==是线程内部方法的内存空间， 一个方法对应一块栈帧内存空间，局部变量就放在栈帧内，遵循FILO规则。")]),a._v(" "),v("p",[a._v("栈帧内部包含5个组件")]),a._v(" "),v("ul",[v("li",[a._v("局部变量表")]),a._v(" "),v("li",[a._v("操作数栈")]),a._v(" "),v("li",[a._v("动态链接")]),a._v(" "),v("li",[a._v("方法出口")])]),a._v(" "),v("h3",{attrs:{id:"局部变量表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#局部变量表"}},[a._v("#")]),a._v(" 局部变量表")]),a._v(" "),v("p",[a._v("放局部变量表的地方")]),a._v(" "),v("h3",{attrs:{id:"操作数栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作数栈"}},[a._v("#")]),a._v(" 操作数栈")]),a._v(" "),v("p",[a._v("临时存放数值的内存空间。当做运算操作时，会把栈顶2个数弹出来，做操作后重新压回栈中")]),a._v(" "),v("h3",{attrs:{id:"动态链接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态链接"}},[a._v("#")]),a._v(" 动态链接")]),a._v(" "),v("p",[a._v("放的是方法内部的代码在元空间中的入口地址")]),a._v(" "),v("h3",{attrs:{id:"方法出口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法出口"}},[a._v("#")]),a._v(" 方法出口")]),a._v(" "),v("p",[a._v("记录的是主线程代码的执行位置、返回值等")]),a._v(" "),v("p",[a._v("补充：javap -c test.class 反编译")]),a._v(" "),v("p",[a._v("Main方法的局部变量是一个对象， 是一块内存空间，是一个对象在堆中的地址（引用）")]),a._v(" "),v("h3",{attrs:{id:"本地方法栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),v("p",[a._v("native修饰，访问C++的接口")]),a._v(" "),v("h3",{attrs:{id:"方法区-元空间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法区-元空间"}},[a._v("#")]),a._v(" 方法区（元空间）")]),a._v(" "),v("p",[a._v("使用的是直接内存（物理内存），放的是常量、静态变量、类信息")]),a._v(" "),v("p",[a._v("方法区的类信息，存的是栈中实例的引用（地址）")]),a._v(" "),v("h3",{attrs:{id:"程序计数器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),v("p",[a._v("记录代码执行的位置，每个线程独有的")]),a._v(" "),v("p",[a._v("栈、本地方法栈、程序计数器是每个线程私有的")]),a._v(" "),v("p",[a._v("堆、方法区是公有的")]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"垃圾回收算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[a._v("#")]),a._v(" 垃圾回收算法")]),a._v(" "),v("h3",{attrs:{id:"_1-mark-sweep-标记清除"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-mark-sweep-标记清除"}},[a._v("#")]),a._v(" 1.Mark-Sweep(标记清除)")]),a._v(" "),v("p",[a._v("仅仅把标记的可回收对象回收了")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202212152256627.png",alt:"标记清除"}})]),a._v(" "),v("h3",{attrs:{id:"_2-复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-复制"}},[a._v("#")]),a._v(" 2.复制")]),a._v(" "),v("p",[a._v("内存空间一切为二，把上面的可回收复制到下面")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202212152256880.png",alt:"复制算法"}})]),a._v(" "),v("h3",{attrs:{id:"_3-标记整理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-标记整理"}},[a._v("#")]),a._v(" 3.标记整理")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202212152256082.png",alt:"标记整理算法"}})]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202212152256253.png",alt:"区别"}})]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"垃圾收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[a._v("#")]),a._v(" 垃圾收集器")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202212152256465.png",alt:"垃圾收集器"}})]),a._v(" "),v("h3",{attrs:{id:"java8以及之前的版本-分代模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java8以及之前的版本-分代模型"}},[a._v("#")]),a._v(" Java8以及之前的版本--分代模型")]),a._v(" "),v("p",[a._v("新生代↓")]),a._v(" "),v("ul",[v("li",[a._v("ParNew")]),a._v(" "),v("li",[a._v("Serial")]),a._v(" "),v("li",[a._v("Parallel Scavenge")])]),a._v(" "),v("p",[a._v("老年代↓")]),a._v(" "),v("ul",[v("li",[a._v("CMS")]),a._v(" "),v("li",[a._v("Serial Old")]),a._v(" "),v("li",[a._v("Parallel Old")])]),a._v(" "),v("h4",{attrs:{id:"_1-使用-xx-useserialgc-新生代使用serial-gc-老年代自动使用serial-old-gc-串行的收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用-xx-useserialgc-新生代使用serial-gc-老年代自动使用serial-old-gc-串行的收集器"}},[a._v("#")]),a._v(" 1.使用-XX:UseSerialGC，新生代使用Serial GC，老年代自动使用Serial Old GC（串行的收集器）")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202212152256686.png",alt:"Serial收集器"}})]),a._v(" "),v("p",[a._v("用户线程访问程序，当新生代要做垃圾回收的时候，线程终止的点叫做Safepoint，开启GC线程回收垃圾，使用Serial垃圾收集器，采用复制算法，串行收集垃圾；老年代使用Serial Old垃圾收集器，采用标记整理算法，暂停所有用户线程（STW），串行做垃圾收集。")]),a._v(" "),v("h4",{attrs:{id:"_2-java8默认-使用-xx-useparallelgc-xx-useparalleloldgc-新生代使用parallel-scavenge-gc-老年代使用parallel-old-gc-并行的收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-java8默认-使用-xx-useparallelgc-xx-useparalleloldgc-新生代使用parallel-scavenge-gc-老年代使用parallel-old-gc-并行的收集器"}},[a._v("#")]),a._v(" 2.==Java8默认==使用-XX:UseParallelGC / -XX:UseParallelOldGC，新生代使用Parallel Scavenge GC，老年代使用Parallel Old GC（并行的收集器）")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202212152256318.png",alt:"ParallelGC"}})]),a._v(" "),v("p",[a._v("用户线程访问程序，当新生代要做垃圾回收的时候，线程终止的点叫做Safepoint，开启GC线程回收垃圾，使用Parallel Scavenge垃圾收集器，采用复制算法，并行收集垃圾；老年代使用Parallel Old垃圾收集器，采用标记整理算法，暂停所有用户线程（STW），并行做垃圾收集。")]),a._v(" "),v("h4",{attrs:{id:"_3-使用-xx-useconcmarksweepgc-新生代使用parnew-gc-老年代使用cms-gc与serial-old-gc的收集器组合-serial-old将作为cms出错的后备收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用-xx-useconcmarksweepgc-新生代使用parnew-gc-老年代使用cms-gc与serial-old-gc的收集器组合-serial-old将作为cms出错的后备收集器"}},[a._v("#")]),a._v(" 3.使用-XX:UseConcMarkSweepGC，新生代使用ParNew GC，老年代使用CMS GC与Serial Old GC的收集器组合，Serial Old将作为CMS出错的后备收集器")]),a._v(" "),v("p",[a._v("新生代")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202212152256629.png",alt:"ParNewGC"}})]),a._v(" "),v("p",[a._v("老年代")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202212152256833.png",alt:"CMS+SerialOld"}})]),a._v(" "),v("p",[a._v("CMS(ConcurrentMarkSweep)步骤如下：")]),a._v(" "),v("p",[a._v("1.初始标记（STW）")]),a._v(" "),v("p",[a._v("gc root开始标记第一层对象")]),a._v(" "),v("p",[a._v("2.并发标记")]),a._v(" "),v("p",[a._v("顺着【gc root->第一层对象】继续标记后续的对象")]),a._v(" "),v("p",[a._v("3.重新标记（STW）")]),a._v(" "),v("p",[a._v("由于并发标记时，有用户线程的干扰，重新标记的作用是==重新把错标、漏标的垃圾重新标记==")]),a._v(" "),v("p",[a._v("4.并发清理")]),a._v(" "),v("p",[a._v("进行垃圾回收")]),a._v(" "),v("p",[a._v("==CMS什么时候有可能出问题==")]),a._v(" "),v("p",[a._v("有可能产生碎片，有新的对象进来老年代，老年代满了->垃圾处理程序出现异常，Serial Old就进场，执行STW机制")]),a._v(" "),v("h3",{attrs:{id:"java9以及以后的版本-分区模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java9以及以后的版本-分区模型"}},[a._v("#")]),a._v(" Java9以及以后的版本--分区模型")]),a._v(" "),v("ul",[v("li",[a._v("G1(Java9)")]),a._v(" "),v("li",[a._v("ZGC(Java11)")]),a._v(" "),v("li",[a._v("Epsilon(Java11)")]),a._v(" "),v("li",[a._v("Shenandoah")])]),a._v(" "),v("hr"),a._v(" "),v("h2",{attrs:{id:"问题分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题分析"}},[a._v("#")]),a._v(" 问题分析")]),a._v(" "),v("h3",{attrs:{id:"_1-java虚拟机为什么要设计一个程序计数器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-java虚拟机为什么要设计一个程序计数器"}},[a._v("#")]),a._v(" 1.Java虚拟机为什么要设计一个程序计数器？")]),a._v(" "),v("p",[a._v("当一个程序被挂起然后再重新执行的时候，程序技术器的作用就是让虚拟机知道，挂起之前的代码执行到哪里")]),a._v(" "),v("h3",{attrs:{id:"_2-程序计数器的值是怎么修改的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-程序计数器的值是怎么修改的"}},[a._v("#")]),a._v(" 2.程序计数器的值是怎么修改的？")]),a._v(" "),v("p",[a._v("字节码执行引擎修改程序计数器的值")]),a._v(" "),v("h3",{attrs:{id:"_3-能不能对jvm调优-使其几乎不发生full-gc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-能不能对jvm调优-使其几乎不发生full-gc"}},[a._v("#")]),a._v(" 3.能不能对jvm调优，使其几乎不发生full gc?")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://pic-new-1304161434.cos.ap-guangzhou.myqcloud.com/img/202211182021367.png",alt:"jvm参数"}})])])}),[],!1,null,null,null);t.default=r.exports}}]);